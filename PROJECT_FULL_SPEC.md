# Полная спецификация проекта Coati

## 1. Обзор и Цели

Система подготовки требований с помощью ИИ.

Фаза 1 подготовки требований: запрос на разработку.

Пользователь вводит запрос на разработку в веб-интерфейсе, отправляет на сервер (n8n).

Сервер принимает, отправляет на уточнение в ИИ (модель выбирает пользователь) вместе с системным промптом, где описана задача по проверке.

ИИ проверяет запрос на неопределенности, возвращает JSON со статусом (есть неопределенности / нет неопределенностей) если есть неопределнности - включает вопросы к неопределенностям в тексте в формате массива объектов, которые содержат: id вопроса, точную цитату из текста запроса, вопрос, тип вопроса.

Сервер отправляет JSON в пользовательский интерфейс, где пользователь вводит ответы на вопросы и отправляет на сервер JSON с ответами на вопросы (тот же JSON, но в объект вопроса добавлен текст ответа), при этом должна быть проверка на то, все ответы заполнены, или нет (должны быть все заполнены, иначе не разрешать отправлять).

Сервер принимает JSON с ответами и отправляет ИИ на проверку качества ответов: если есть ответы не по делу или некачественные, он должен добавить строку с замечаниями к ответам, и сервер должен вернуть ответы в пользовательский интерфейс, где пользователь должен увидеть отправленные ответы с замечаниями ИИ, и уточнить ответы (пользовательский интерфейс не должен принимать от пользователя ответы, если он их не изменил), и отправить обратно на сервер.

Сервер снова принимает, и проверяет качество ответов. Если проверка качества не прошла - снова возвращает пользователю, если проверка качества прошла, то сервер передает ответы ИИ для уточнения запроса на разработку на основании ответов пользователя.

ИИ генерирует уточненный запрос, и передает серверу, а сервер передает уточненный запрос в пользовательский интерфейс для ревизии пользователем.

Пользователь проверяет, и если необходимо - вносит правки, после чего отправляет проверенный запрос на сервер.

Сервер принимает, и передает ИИ для проверки на неопределенность, и если ИИ находит неопределенность, процесс устранения неопределенности повторяется. Если ИИ не находит неопределенность в уточненном запросе, то сервер сохраняет уточненный запрос на разработку.

Нужно сделать подробное описание процесса 1 этапа, в котором будет описано взаимодействие пользователя, пользовательского интерфейса, сервера, ИИ. Описать реализацию системы. Нужно проверить сначала этот запрос, если есть необходимость - задать уточняющие вопросы. Сервер - n8n, пользовательский интерфейс - статический сайт html+js+API, ИИ подключается к n8n по API.

## 2. Технический стек

### Финальное решение:

Frontend: React (SPA) + Ant Design/MUI. Editor: TipTap (ProseMirror) — блочный редактор с контейнерами.

Backend / Middleware: n8n. Роль API Gateway, Оркестратора логики и Интегратора ИИ-сервисов.

Database: ArangoDB (Graph + Document). Хранение пользователей, проектов, атомарных требований и связей.

AI & Integration: Подключение по API (OpenAI, Anthropic и др.). Управление через n8n.

Infrastructure: Docker Compose (n8n + ArangoDB на одном хосте для MVP).

### Альтернативы/Отказались:

Статический сайт html+js+API (нет React).

Сервер - n8n, ИИ подключается к n8n по API.

## 3. Архитектура и Структура данных

### Финальное решение:

База данных ArangoDB, гибридный режим: Document Collections и Edge Collections.

3.1. Справочники (System Dictionaries)

Коллекция Dictionaries — для хранения системных констант.

Создание документов с полями:

- _key (идентификатор справочника).

- values (массив допустимых значений).

Примеры:

- "step_types": ["ambiguity_loop", "simple_generation", "quality_gate", "compliance_check", "traceability_scan"].

- "prompt_categories": ["Business Requirements", "Functional Requirements", "API", "Security", "UX"].

- "document_types": ["Brief", "SRS", "UserStories", "TestCases"].

- "user_roles": ["owner", "editor", "reader"].

- "ai_providers": ["openai", "anthropic", "google"].

3.2. Пользователи и Доступ (Auth & Access)

Document Collection: Users

- _key (UUID).

- email (Unique Index).

- password_hash (Hash пароля).

- name (Отображаемое имя).

- is_blocked (Boolean).

- created_at (Timestamp).

Document Collection: Invites

- _key (UUID).

- email (Email приглашенного).

- project_id (Ссылка на проект).

- role (Роль: "editor" или "reader").

- token (Уникальный токен для ссылки).

- status ("pending", "accepted", "expired").

- expires_at (Timestamp).

Edge Collection: MemberOf

- _from (Users/user_id).

- _to (Projects/project_id).

- role (Роль в проекте).

3.3. Структура Проекта и Гибкие Этапы

Document Collection: Projects

- _key (UUID).

- name (Название).

- description (Описание).

- created_by (ID создателя).

- created_at (Timestamp).

- status ("active", "archived").

Document Collection: Stages (Этапы)

- _key (UUID).

- project_id (Ссылка на проект).

- name (Название этапа).

- order (Integer, порядковый номер).

- default_model_id (ID модели ИИ по умолчанию).

- steps (Массив объектов, каждый содержит: id, type, prompt_id, order, is_required, config).

Document Collection: Documents (Артефакты)

- _key (UUID).

- project_id (ID проекта).

- stage_id (ID этапа).

- type (Тип документа).

- status ("draft", "processing", "review", "approved").

- version (Integer).

- created_at (Timestamp).

Edge Collection: DocLink (Связи документов)

- _from (Documents/source_doc_id).

- _to (Documents/target_doc_id).

- type ("source_for").

- Описание: Цепочка происхождения (Lineage).

3.4. Контент Требований (Atomic Content)

Document Collection: Requirements

- _key (UUID).

- human_id (Читаемый ID: "BR-001").

- type ("container", "heading", "paragraph", "image").

- content (JSON TipTap/ProseMirror структуры).

- metadata: { priority, author_id, status }.

- quality_score (Числовая оценка качества).

Edge Collection: Structure (Иерархия)

- _from (Documents/doc_id или Requirements/parent_req_id).

- _to (Requirements/child_req_id).

- position (Integer, порядок).

- Описание: Дерево документа.

Edge Collection: Traceability (Трассировка)

- _from (Requirements/source_id).

- _to (Requirements/target_id).

- type ("depends_on", "conflicts_with", "refines", "verifies").

3.5. Конфигурация ИИ и Логи (AI & Logs)

Document Collection: AI_Models

- _key (ID модели: "gpt-4o").

- name (Отображаемое имя).

- provider (Из справочника ai_providers).

- context_window (Integer, лимит токенов).

- max_output_tokens (Integer).

Document Collection: Prompts

- _key (UUID).

- title (Название).

- content (Текст шаблона).

- category (Из справочника prompt_categories).

- compatible_step_types (Массив типов шагов).

- language ("ru", "en").

- is_system (Boolean).

Document Collection: Iterations (История)

- _key (UUID).

- project_id (ID проекта).

- stage_id (ID этапа).

- step_type (Тип шага).

- prompt_uid (Ссылка на промпт).

- model_uid (Ссылка на модель).

- user_id (Кто инициировал).

- input_tokens (Integer).

- output_tokens (Integer).

- timestamp (Timestamp).

- user_feedback (Опционально, оценка).

Document Collection: Attachments (Файлы)

- _key (UUID).

- project_id (ID проекта).

- stage_id (ID этапа).

- filename (Имя файла).

- file_type (Расширение/MIME).

- parsed_text (Извлеченный текст).

- size_tokens (Размер в токенах).

- uploaded_at (Timestamp).

### Альтернативы/Отказались:

Проекты, Requests (Brifs), Iterations - сущности для хранения истории вопросов и ответов.

Хранение в клиентском браузере (толстый клиент) - отказались, выбрали серверное хранение.

Одна n8n или разные Workflow - отказались, один Workflow с роутером.

Два сервера (ArangoDB отдельно) - выбрали один в Docker.

n8n и ArangoDB на одном сервере.

Требования хранить как массив или отдельно - отказались от массива, выбрали отдельные документы.

Типы вопросов (clarification, completeness, constraint, logic).

Изменениями - genesis текст, так как Requirements атомарно.

Отказались от хранения метки на полях - выбрали визуализацию ID в редакторе.

Коллекции: Projects, Requests (именована Brief), Iterations.

ArangoDB (графовая БД) - выбрали.

## 4. Детальный Workflow и Типы Шагов

### Финальное решение:

Шаг 0: Инициализация и Ввод Данных (Input & Context)

Пользователь вводит исходный текст или использует результат предыдущего этапа.

Загрузка файлов: Пользователь прикрепляет PDF, DOCX, TXT.

Системная обработка: Парсинг файлов в текст, токенизация, валидация лимитов.

UI: Token Meter (шкала заполненности контекста, красный при переполнении).

Шаг 1: Анализ Неопределенностей (Ambiguity Check)

ИИ анализирует текст на проблемы (противоречия, пропуски).

Результат: JSON со статусом (clean/ambiguous), списком вопросов.

Ветвление: Если clean -> Шаг 3; Если ambiguous -> Шаг 2.

Шаг 2: Цикл Уточнения (Q&A Loop)

UI (Split View):

- Левая сторона: Исходный текст (Read-only), подсветка цитат вопросов.

- Правая сторона: Форма вопросов.

Обработка ответов:

- ИИ проверяет качество (отсеивает отписки).

- Валидация: Красная подсветка ошибок, блокировка отправки при неудаче.

- Force Submit: Пропуск качества.

Шаг 3: Генерация Артефакта (Generation)

ИИ генерирует документ на основе контекста.

Сохранение: Черновик в базу (структура Requirements).

UI: Индикатор прогресса.

Шаг 4: Сверка и Аудит (Compliance Check)

ИИ сравнивает исходник и результат на потери/добавления.

UI: Сайдбар с отчетом сверки (Diff View, цвета: зелёный/жёлтый/красный).

Шаг 5: Финализация (Final Review)

Пользователь редактирует документ в TipTap.

Действия: "Утвердить", "Перегенерировать", "Вернуться к вопросам".

### Альтернативы/Отказались:

Из чата: Детальное описание процесса (Workflow) - отказались от части, так как перешли к модульной архитектуре.

Шаг 0: Инициализация. Пользователь создает проект. В интерфейсе выбирает модель ИИ.

Шаг 1: Первичный запрос (User -> Server) - UI: Пользователь вводит текст запроса в textarea. Нажимает «Отправить». API: POST /webhook/analyze-request Body: { projectId, requestText, model }. n8n: Сохраняет/Обновляет Request в ArangoDB. RAG/Context: Собирает контекст проекта из ArangoDB. AI Call (Ambiguity Check): Отправляет текст + системный промпт. Logic: Если ИИ вернул status: "clean" -> Переход к Шагу 4 (Генерация ТЗ). Если ИИ вернул status: "ambiguous" -> Сохраняет вопросы в БД. Response: Возвращает JSON со списком вопросов или статус успеха.

Шаг 2: Ответы на вопросы (User <-> Server Loop) - UI: Отображает список вопросов. Поля ввода заблокированы для отправки, пока все не заполнены. Кнопка «Отправить ответы» (Основная). Кнопка «Принять ответы без анализа ИИ» (Force Submit) — с предупреждением. API: POST /webhook/submit-answers Body: { requestId, answers: [{id, text}], force: boolean }. n8n: Ветка Force (force=true): Пропускает проверку качества, сразу переходит к сохранению ответов и переходу на Шаг 4. Ветка Normal (force=false): AI Call (Quality Check): Отправляет пары Вопрос-Ответ на проверку. Logic: Если quality: "pass" -> Переход к Шагу 4. Если quality: "fail" -> Возвращает массив замечаний (feedback). UI (при наличии замечаний): Отображает замечания красным цветом под соответствующими полями. Блокировка: Кнопка «Отправить» (disabled), пока пользователь не изменит текст в полях с замечаниями (слушатель события input).

Шаг 3: Генерация Уточненного Запроса (Server -> AI) - n8n: Собирает: Исходный запрос + (Вопросы + Ответы пользователя). AI Call (Refinement): Генерирует итоговый документ в Markdown. Сохраняет refined_text в ArangoDB. Response: Возвращает Markdown клиенту.

Шаг 4: Ревизия Пользователем (User -> Server Loop) - UI: Показывает Markdown (рендеринг). Пользователь может нажать «Редактировать» и внести правки прямо в текст. Action: Пользователь нажимает «Утвердить» или отправляет исправленный текст. API: POST /webhook/finalize-request Body: { requestId, refinedText }. n8n: AI Call (Re-Check): Проверяет новый текст на неопределенности (как в Шаге 1). Logic: Если есть новые неопределенности -> Возвращает список новых вопросов (Цикл возвращается на Шаг 2). Если чисто -> Сохраняет финальный статус completed.

Также типы вопросов: clarification, completeness, constraint, logic.

## 5. Функциональные требования (Подробно)

Общая компоновка:

Верхняя панель: Project Timeline (горизонтальный степпер этапов).

Центральная область: Split View (Редактор + Q&A) или Full Editor.

Правая панель: Stage Control & Context (вертикальный таймлайн шагов, настройки модели/промпта).

Левая панель: Навигация (проекты, настройки).

Интерфейс Q&A: Карточки вопросов с полями ввода, автоскролл к цитате (toggleable).

Блочный Редактор: TipTap с вложенными контейнерами, визуализация ID требований, Drag & Drop.

Настройки проекта:

Workflow: Drag & Drop этапов, Add/Delete.

Команда: Email-инвайты, роли (Owner/Editor/Reader).

Профиль: Изменение имени/пароля.

Админка: Таблица пользователей, B/R/U/D.

## 6. Интеграции и API

Интеграции:

Файловые парсеры: pdf-parse, mammoth (для docx).

AI API: OpenAI/ Anthropic (через n8n).

Email: SMTP для инвайтов.

Git: Экспорт в репозиторий (Markdown commit).

API:

Auth: /auth/register, /auth/login, /auth/invite.

Projects: CRUD для проектов/этапов.

AI: /ai/process-step (запускает Workflow).

Files: /files/upload (обработка и embedding).

## 7. ❓ Вопросы и Неопределенности

Точная реализация RAG в n8n: Нужно ли использовать встроенные Vector Store ноды или кастомные?

Масштабирование: Как обрабатывать большие документы (больше 100 требований) — добавить пагинацию или иерархическую загрузку?

Интерфейс Traceability: Как визуализировать большой граф (библиотека типа D3.js или готовый компонент)?

Вопросы неопределенности отсутствуют, так как все детали обговорены в ходе анализа чата.
