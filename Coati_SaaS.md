# Coati SaaS

---

# Раздел 1. Обзор и Цели

## 1.1. Название и Суть Проекта
**Проект:** AI-Driven Requirements Management System (AI-RMS).
**Тип:** SaaS-платформа (Software as a Service).

Это система для автоматизированной и совместной разработки требований к программному обеспечению. В отличие от обычных чат-ботов (ChatGPT), которые просто генерируют текст, данная платформа реализует **агентный подход**: ИИ выступает в роли квалифицированного бизнес-аналитика, который ведет пользователя по строгому процессу выявления требований, не допуская создания поверхностных или противоречивых документов.

## 1.2. Основные Цели
1.  **Устранение неопределенности:** Автоматическое выявление "серых зон" в запросах заказчика до начала разработки. Система не позволяет перейти к генерации ТЗ, пока не будут разрешены критические смысловые пробелы.
2.  **Структуризация знаний:** Переход от хранения требований в виде монолитных текстовых файлов (Word/Google Docs) к **атомарной графовой структуре**. Каждое требование — это отдельный объект базы данных, что позволяет отслеживать связи, версии и статус каждого конкретного пункта.
3.  **Контроль качества (Compliance):** Гарантия того, что итоговый документ соответствует исходному запросу. ИИ выполняет роль аудитора, сверяя результат с исходными данными и подсвечивая любые отклонения или упущения.
4.  **Гибкость процесса:** Возможность настраивать цепочку производства документации (Workflow) под конкретный проект — от простого "Брифа" до сложной цепочки "Бизнес-требования -> Функциональные требования -> API Спецификация" с использованием специализированных промптов.

## 1.3. Ключевые Возможности
*   **Итеративный диалог:** Умный цикл "Анализ -> Вопросы -> Проверка ответов -> Генерация", который заставляет пользователя давать качественные входные данные.
*   **SaaS и Коллаборация:** Многопользовательский доступ, разделение на проекты и воркспейсы, ролевая модель (Редактор/Читатель), система приглашений.
*   **Блочный Редактор (Block Editor):** Современный интерфейс редактирования (аналог Notion/Confluence), который скрывает от пользователя сложность графовой базы данных, предоставляя привычный опыт работы с документом.
*   **Работа с контекстом:** Поддержка загрузки файлов (PDF, DOCX) и автоматический контроль лимитов контекстного окна выбранной модели ИИ.

---

# Раздел 2. Технологический Стек

Для реализации проекта выбран стек, обеспечивающий баланс между гибкостью разработки (Low-Code для логики) и производительностью интерфейса (React для UI).

## 2.1. Frontend (Клиентская часть)
*   **Фреймворк:** **React** (Single Page Application).
    *   Обеспечивает реактивность интерфейса, необходимую для сложного редактора и чата.
*   **UI Библиотека:** **Ant Design** или **Material UI (MUI)**.
    *   Готовый набор компонентов (таблицы, модальные окна, формы, уведомления) для ускорения разработки админки и настроек.
*   **Ядро Редактора:** **TipTap** (на базе ProseMirror).
    *   Headless-редактор, позволяющий полностью кастомизировать рендеринг блоков.
    *   Критически важен для реализации концепции «Требование-Контейнер» и привязки уникальных ID к блокам текста.
*   **Стейт-менеджмент:** Redux Toolkit или Zustand (для хранения состояния сессии, загруженных файлов и кэша документов).

## 2.2. Backend / Middleware (Бизнес-логика)
*   **Платформа:** **n8n** (Workflow Automation Tool).
    *   Выполняет роль **API Gateway**: Принимает все REST-запросы от Frontend.
    *   Выполняет роль **Orchestrator**: Управляет логикой авторизации, валидации данных, вызовами ИИ и записью в БД.
    *   Позволяет быстро менять логику обработки промптов без пересборки кода.
*   **Обработка файлов:** Встроенные ноды n8n или внешние утилиты (в Docker-контейнере) для парсинга PDF/DOCX в чистый текст.

## 2.3. Database (Хранение данных)
*   **СУБД:** **ArangoDB**.
    *   **Тип:** Мультимодельная (Document + Graph).
    *   **Роль:** Единое хранилище для всех данных.
    *   **Использование Графов:** Для хранения связей (Traceability) между требованиями, пользователями и проектами.
    *   **Использование Документов:** Для хранения профилей пользователей, конфигураций и контента требований (JSON).

## 2.4. AI & Integration (Искусственный Интеллект)
*   **Провайдеры:** Подключение по API (OpenAI, Anthropic, Google Gemini и др.).
*   **Управление:** Настройка ключей и параметров моделей (temperature, top_p) осуществляется внутри n8n (Credentials) или через базу данных (для выбора модели в UI).

## 2.5. Infrastructure (Инфраструктура)
*   **Среда:** **Docker Compose**.
    *   Контейнер 1: `n8n` (Бэкенд).
    *   Контейнер 2: `arangodb` (База данных).
    *   Контейнер 3: `frontend` (Nginx, раздающий статику React-приложения).
*   **Сетевое взаимодействие:**
    *   Frontend обращается к n8n через публичный порт (напр. 443/5678).
    *   n8n обращается к ArangoDB через внутреннюю сеть Docker (порт 8529), база данных не доступна извне напрямую.

---

# Раздел 3. Архитектура Данных (ArangoDB)

База данных ArangoDB используется в гибридном режиме: коллекции документов для сущностей и коллекции ребер (Edges) для связей.

## 3.1. Справочники (System Dictionaries)
Коллекция для хранения системных констант и списков, обеспечивающая гибкость настройки без изменения кода.

**Document Collection: `Dictionaries`**
*   `_key`: Уникальный идентификатор справочника (напр. `step_types`).
*   `values`: Массив допустимых строковых значений.
    *   *Пример `step_types`:* `["ambiguity_loop", "simple_generation", "quality_gate", "compliance_check", "traceability_scan"]`.
    *   *Пример `prompt_categories`:* `["Business Requirements", "Functional Requirements", "API", "Security", "UX"]`.
    *   *Пример `document_types`:* `["Brief", "Concept", "SRS", "UserStories", "TestCases"]`.
    *   *Пример `user_roles`:* `["owner", "editor", "reader"]`.
    *   *Пример `ai_providers`:* `["openai", "anthropic", "google", "ollama"]`.

Да, в текущем дизайне **Раздела 3** я предложил хранить их в **одной коллекции** `Dictionaries`.

**Почему так сделано:**
1.  **Простота:** В ArangoDB (NoSQL) нет смысла создавать 10 отдельных коллекций, если в каждой из них будет лежать всего по 5-10 документов (например, 3 роли, 5 типов файлов). Это "замусоривает" список коллекций.
2.  **Гибкость:** Вы можете добавить новый справочник (например, "Языки интерфейса") просто создав один документ, не меняя схему БД и не создавая новую таблицу/коллекцию.
3.  **Производительность:** Фронтенд может одним запросом забрать все справочники при инициализации приложения.

**Как это выглядит внутри:**
Коллекция `Dictionaries` содержит документы. Каждый документ — это отдельный справочник.

*   Документ 1 (`_key: "user_roles"`):
    ```json
    {
      "values": [
        { "id": "owner", "label": "Владелец", "description": "Полный доступ" },
        { "id": "editor", "label": "Редактор", "description": "Может менять контент" }
      ]
    }
    ```
*   Документ 2 (`_key: "prompt_categories"`):
    ```json
    {
      "values": ["БТ", "ФТ", "API", "UX"]
    }
    ```

**Альтернатива:**
Если справочник станет огромным (тысячи записей) или потребует сложных связей, его нужно будет вынести в отдельную коллекцию. Но для типов документов, ролей и категорий подход "Одна коллекция Dictionaries" является стандартом для NoSQL систем.

## 3.2. Пользователи и Доступ (Auth & Access)

**Document Collection: `Users`**
*   `_key`: UUID пользователя.
*   `email`: Email адрес (Unique Index).
*   `password_hash`: Хеш пароля.
*   `name`: Отображаемое имя.
*   `is_blocked`: Boolean (блокировка администратором).
*   `created_at`: Timestamp регистрации.

**Document Collection: `Invites`**
*   `_key`: UUID приглашения.
*   `email`: Email приглашенного пользователя.
*   `project_id`: ID проекта, в который приглашают.
*   `role`: Роль, которая будет назначена (`editor` или `reader`).
*   `token`: Уникальный токен для ссылки активации.
*   `status`: Статус приглашения (`pending`, `accepted`, `expired`).
*   `expires_at`: Timestamp истечения срока действия.

**Edge Collection: `MemberOf`**
*   `_from`: `Users/{user_id}`
*   `_to`: `Projects/{project_id}`
*   `role`: Роль пользователя в данном проекте (валидируется по справочнику `user_roles`).

## 3.3. Структура Проекта (Hierarchy)

**Document Collection: `Projects`**
*   `_key`: UUID проекта.
*   `name`: Название проекта.
*   `description`: Текстовое описание.
*   `created_by`: ID пользователя-создателя.
*   `created_at`: Timestamp создания.
*   `status`: Статус проекта (`active`, `archived`).

**Document Collection: `Stages` (Этапы)**
*   `_key`: UUID этапа.
*   `project_id`: Ссылка на родительский проект.
*   `name`: Название этапа (напр. "Сбор Бизнес-требований").
*   `order`: Integer (порядковый номер этапа в Workflow проекта).
*   `default_model_id`: ID модели ИИ, используемой по умолчанию на этом этапе.
*   `steps`: **Массив объектов (Шаги)**. Каждый объект содержит:
    *   `id`: Локальный ID шага (string).
    *   `type`: Тип шага (валидируется по справочнику `step_types`).
    *   `prompt_id`: Ссылка на `Prompts/{id}`, используемый на этом шаге.
    *   `order`: Порядковый номер шага внутри этапа.
    *   `is_required`: Boolean (обязателен ли шаг).
    *   `config`: JSON-объект с дополнительными параметрами (опционально).

**Document Collection: `Documents` (Артефакты)**
*   `_key`: UUID документа.
*   `project_id`: Ссылка на проект.
*   `stage_id`: Ссылка на этап, в рамках которого создан документ.
*   `type`: Тип документа (валидируется по справочнику `document_types`).
*   `status`: Текущий статус (`draft`, `processing`, `review`, `approved`).
*   `version`: Номер версии (Integer).
*   `created_at`: Timestamp.

**Edge Collection: `DocLink` (Связи документов)**
*   `_from`: `Documents/{source_doc_id}` (Родительский документ).
*   `_to`: `Documents/{target_doc_id}` (Производный документ).
*   `type`: Тип связи (напр. `source_for`).
*   *Описание:* Используется для построения цепочки происхождения (Lineage), чтобы понимать, на основе какого Брифа было создано ТЗ.

## 3.4. Контент Требований (Atomic Content)

**Document Collection: `Requirements`**
*   `_key`: UUID требования (атомарного блока).
*   `human_id`: Читаемый идентификатор (напр. "BR-005"), уникальный в рамках проекта.
*   `type`: Тип блока (`container`, `heading`, `paragraph`, `image`).
*   `content`: JSON-структура (формат TipTap/ProseMirror) с контентом блока.
*   `metadata`: Объект с метаданными (`priority`, `author_id`, `status`).
*   `quality_score`: Числовая оценка качества требования от ИИ (0-100).

**Edge Collection: `Structure` (Иерархия)**
*   `_from`: `Documents/{doc_id}` или `Requirements/{parent_req_id}`.
*   `_to`: `Requirements/{child_req_id}`.
*   `position`: Integer (порядок отображения внутри родителя).
*   *Описание:* Формирует дерево документа.

**Edge Collection: `Traceability` (Трассировка)**
*   `_from`: `Requirements/{source_id}`.
*   `_to`: `Requirements/{target_id}`.
*   `type`: Тип смысловой связи (`depends_on`, `conflicts_with`, `refines`, `verifies`).

## 3.5. Конфигурация ИИ и Логи (AI & Logs)

**Document Collection: `AI_Models`**
*   `_key`: ID модели (напр. `gpt-4o`).
*   `name`: Отображаемое имя в UI.
*   `provider`: Провайдер (валидируется по справочнику `ai_providers`).
*   `context_window`: Максимальное количество токенов контекста (Integer).
*   `max_output_tokens`: Лимит токенов на вывод (Integer).
*   `cost_per_1k_tokens`: Стоимость (для биллинга в будущем).

**Document Collection: `Prompts`**
*   `_key`: UUID промпта.
*   `title`: Название промпта.
*   `content`: Текст шаблона промпта (с переменными).
*   `category`: Категория (валидируется по справочнику `prompt_categories`).
*   `compatible_step_types`: Массив типов шагов, где этот промпт применим.
*   `language`: Язык промпта (`ru`, `en`).
*   `is_system`: Boolean (true = системный, false = пользовательский).

**Document Collection: `Iterations` (История запросов)**
*   `_key`: UUID записи лога.
*   `project_id`: ID проекта.
*   `stage_id`: ID этапа.
*   `step_type`: Тип шага, на котором произошел вызов.
*   `prompt_uid`: Ссылка на использованный промпт.
*   `model_uid`: Ссылка на использованную модель.
*   `user_id`: Кто инициировал запрос.
*   `input_tokens`: Количество входных токенов.
*   `output_tokens`: Количество выходных токенов.
*   `timestamp`: Время запроса.
*   `user_feedback`: Оценка пользователя (лайк/дизлайк/комментарий).

**Document Collection: `Attachments` (Файлы)**
*   `_key`: UUID файла.
*   `project_id`: ID проекта.
*   `stage_id`: ID этапа (к которому прикреплен).
*   `filename`: Оригинальное имя файла.
*   `file_type`: Расширение/MIME-тип.
*   `parsed_text`: Извлеченный текстовый контент (для отправки в ИИ).
*   `size_tokens`: Размер файла в токенах.
*   `uploaded_at`: Timestamp.

---

# Раздел 4. Детальный Workflow и Типы Шагов

В этом разделе описаны атомарные типы шагов, поддерживаемые системой. Логика n8n построена так, что при запуске этапа она считывает массив `steps` из конфигурации этапа (см. Раздел 3) и последовательно выполняет указанные блоки.

## 4.1. Библиотека Типов Шагов (Step Types Library)

Ниже перечислены доступные модули логики.

### Тип А: `ambiguity_loop` (Цикл устранения неопределенности)
Самый сложный интерактивный шаг.
*   **Вход:** Текст/Контекст + Системный промпт анализа + Системный промпт проверки качества.
*   **Логика (n8n):**
    1.  ИИ анализирует входные данные.
    2.  Если найдены проблемы -> Возвращает JSON с вопросами.
    3.  Ожидает ввода пользователя (Webhook/Wait node).
    4.  Получив ответы, запускает проверку качества (Quality Gate).
    5.  Если качество низкое -> Возвращает ошибку валидации.
    6.  Если ОК -> Сохраняет пары "Вопрос-Ответ" в контекст и завершает шаг.
*   **UI:**
    *   Отображение списка вопросов.
    *   Форма ввода ответов с валидацией (красная подсветка ошибок).
    *   Кнопка "Force Submit" (пропуск проверки качества).
*   **БД:** Запись в `Iterations` (дважды: анализ и проверка).

### Тип Б: `simple_generation` (Генерация)
Шаг создания контента.
*   **Вход:** Накопленный контекст (исходник + файлы + ответы из прошлого шага) + Промпт генерации + Шаблон.
*   **Логика (n8n):**
    1.  Собирает весь контекст в один промпт.
    2.  Отправляет запрос в ИИ.
    3.  Парсит ответ (Markdown/JSON).
    4.  Создает документ в коллекции `Documents` (статус `draft`) и узлы в `Requirements`.
*   **UI:**
    *   Индикатор загрузки ("ИИ пишет документ...").
    *   По завершении — обновление редактора текстом.
*   **БД:** Создание `Documents`, `Requirements`, `Structure`.

### Тип В: `compliance_check` (Сверка / Аудит)
Шаг контроля качества результата.
*   **Вход:** Исходные данные (Input) + Результат генерации (Output) + Промпт сверки.
*   **Логика (n8n):**
    1.  Отправляет оба текста в ИИ с просьбой найти расхождения.
    2.  Получает JSON-отчет (`added`, `missing`, `modified`).
*   **UI:**
    *   Сайдбар или модальное окно "Результаты сверки".
    *   Цветовая индикация (Зеленый/Желтый/Красный).
*   **БД:** Запись отчета в метаданные документа или временное хранилище сессии.

### Тип Г: `manual_review` (Ручное утверждение)
Шаг остановки процесса до решения человека.
*   **Логика:** Процесс n8n встает на паузу (Wait for Trigger).
*   **UI:**
    *   Полнофункциональный редактор TipTap.
    *   Кнопки действий: "Утвердить" (переход к след. этапу), "Перегенерировать" (возврат к Типу Б), "Вернуться к вопросам" (возврат к Типу А).

---

## 4.2. Пример сборки Этапа: "Уточнение Запроса"

Рассмотрим, как эти "кирпичики" собираются в реальный Workflow для первого этапа проекта.

**Конфигурация в БД (`Stages`):**
```json
"steps": [
  { "order": 1, "type": "ambiguity_loop", "prompt_id": "p_analysis_v1" },
  { "order": 2, "type": "simple_generation", "prompt_id": "p_brief_gen_v1" },
  { "order": 3, "type": "compliance_check", "prompt_id": "p_audit_v1" },
  { "order": 4, "type": "manual_review" }
]
```

**Сценарий выполнения:**

1.  **Старт:** Пользователь вводит "Хочу CRM для пиццерии" и жмет "Запуск".
2.  **Шаг 1 (Ambiguity):**
    *   Система видит, что запрос слишком короткий.
    *   **UI:** Показывает вопросы: "Какие роли нужны?", "Нужна ли интеграция с кухней?".
    *   Пользователь отвечает: "Роли: админ, курьер. Кухня: да".
    *   ИИ проверяет ответы -> ОК.
3.  **Шаг 2 (Generation):**
    *   Система берет "Хочу CRM..." + "Роли: админ..." и генерирует Бриф.
    *   **UI:** В редакторе появляется красивый документ.
4.  **Шаг 3 (Compliance):**
    *   ИИ сверяет Бриф с ответами.
    *   **UI:** Показывает плашку: "✅ Все требования из переписки учтены".
5.  **Шаг 4 (Review):**
    *   Пользователь читает, правит пару слов и жмет "Утвердить".
    *   Этап завершен.

---

# Раздел 5. Функциональные Требования (UI/UX)

Интерфейс системы спроектирован для обеспечения фокуса на работе с требованиями, предоставляя контекстную помощь ИИ именно там, где она нужна.

## 5.1. Общая Компоновка (Layout)

**1. Верхняя панель (Project Timeline):**
*   Расположена над центральной областью.
*   Представляет собой **Горизонтальный степпер**, отображающий жизненный цикл проекта (напр. `1. Бриф` -> `2. Бизнес-требования` -> `3. Архитектура`).
*   Показывает текущий активный этап.
*   Позволяет кликнуть на завершенные этапы для просмотра их результатов (в режиме Read-only).

**2. Центральная область (Рабочая зона):**
*   Занимает основное пространство экрана.
*   **Режимы отображения:**
    *   **Full Editor:** (Используется на шагах Ввода, Ручной правки и Финализации). Редактор TipTap занимает всю ширину рабочей зоны.
    *   **Split View (Q&A Mode):** (Используется на шаге Уточнения). Экран делится вертикально:
        *   *Слева (60%):* Редактор с исходным текстом (Read-only). Цитаты, вызвавшие вопросы ИИ, подсвечены фоновым цветом (Highlight).
        *   *Справа (40%):* Панель с формой вопросов и ответов.

**3. Правая панель (Stage Control & Context):**
*   Сворачиваемая боковая панель.
*   **Вкладка "Процесс" (Stage Timeline):**
    *   **Вертикальный таймлайн:** Отображает последовательность шагов внутри текущего этапа (напр. `● Анализ` -> `○ Уточнение` -> `○ Генерация`).
    *   **Статусы:** Визуальная индикация (Галочка = Выполнено, Спиннер = В работе, Серый круг = Ожидание).
    *   **Настройки шага:** Для предстоящих шагов (которые еще не запущены) отображаются выпадающие списки для выбора **Модели ИИ** и **Системного Промпта**.
*   **Вкладка "Контекст":**
    *   Список загруженных файлов.
    *   Token Meter (индикатор заполненности контекстного окна).

**4. Левая панель (Навигация):**
*   Список доступных проектов.
*   Кнопка перехода в Настройки проекта.
*   Профиль пользователя.

## 5.2. Интерфейс Q&A (Split View)

Реализует взаимодействие пользователя с вопросами ИИ.

*   **Связь Вопрос-Текст:**
    *   Каждый вопрос в правой части привязан к конкретному фрагменту текста в левом редакторе.
    *   *Hover-эффект:* При наведении курсора на карточку вопроса, соответствующий фрагмент текста слева подсвечивается ярче.
*   **Управление Навигацией (Скролл):**
    *   **Переключатель "Автоскролл":** Тоггл в заголовке панели вопросов.
        *   *ВКЛ (Default):* Клик на карточку вопроса плавно прокручивает левый редактор к цитате.
        *   *ВЫКЛ:* Клик на вопрос не вызывает прокрутку (чтобы не терять текущую позицию чтения).
    *   **Кнопка "Показать в контексте":** Появляется рядом с вопросом только если Автоскролл выключен. При нажатии принудительно скроллит к цитате.
*   **Форма Ответов:**
    *   Поле ввода ответа находится внутри карточки вопроса.
    *   Валидация: Ошибки от Quality Gate (напр. "Ответ неполный") отображаются красным текстом под полем ввода.
    *   Кнопки действий: "Отправить ответы" (блокируется при ошибках) и "Force Submit" (скрыта в меню "Дополнительно").

## 5.3. Блочный Редактор (TipTap)

Основной инструмент для работы с контентом требований.

*   **Структура:**
    *   Поддержка вложенности (Nested Blocks) для реализации концепции "Требование-Контейнер".
    *   Стандартное форматирование: Заголовки, Списки, Таблицы, Жирный/Курсив.
*   **Идентификация:**
    *   Уникальные ID требований (напр. `BR-001`) отображаются визуально рядом с блоком (на полях или как Badge).
    *   ID генерируются автоматически при создании нового блока-контейнера.
*   **Drag & Drop:**
    *   Возможность менять порядок требований перетаскиванием за "ручку" (Handle) слева от блока.

## 5.4. Панель "Файлы и Контекст"

*   **Upload Zone:** Область для перетаскивания файлов (PDF, DOCX, TXT).
*   **Token Meter:**
    *   Визуальная шкала (Прогресс-бар), показывающая процент использования контекстного окна выбранной модели.
    *   Цветовая индикация: Зеленый (<80%), Желтый (80-95%), Красный (>100% — блокировка запуска).
*   **Управление файлами:** Список с возможностью удаления ошибочно загруженных файлов.

## 5.5. Настройки Проекта (Settings)

*   **Вкладка "Workflow":**
    *   Список этапов в виде карточек.
    *   Drag & Drop для изменения порядка этапов.
    *   Кнопка "Добавить этап": Открывает библиотеку шаблонов этапов.
    *   Кнопка "Удалить этап": Требует подтверждения, если этап содержит данные.
*   **Вкладка "Команда":**
    *   Таблица участников: Email, Роль (`Editor`/`Reader`), Статус приглашения.
    *   Кнопка "Пригласить": Форма ввода Email и выбора Роли.

## 5.6. Админка и Профиль

*   **Профиль пользователя:**
    *   Редактирование имени.
    *   Смена пароля (Текущий -> Новый -> Подтверждение).
*   **Панель Администратора (Super Admin):**
    *   Таблица всех пользователей системы.
    *   Фильтры по Email и Статусу.
    *   Действия: "Заблокировать доступ", "Разблокировать", "Сбросить пароль" (ручная установка временного пароля).

## 5.7. Дизайн-система (Atomic UI & Component Architecture)

Проект использует современный подход к построению интерфейсов, основанный на методологии **Atomic Design** и компонентной инкапсуляции стилей. Мы отказались от использования глобальных CSS-классов (кроме базовых сбросов) и директивы `@apply` в пользу **Reusable UI Components**.

### 5.7.1. Принципы разработки UI
1.  **Clean JSX (Чистый код страниц):** Логика страниц (`pages/`) не содержит длинных строк классов Tailwind. Вместо `div className="p-4 bg-white..."` используются семантические компоненты `<Card>`, `<Button>`, `<Input>`.
2.  **Encapsulation (Инкапсуляция):** "Суп из классов" (Utility Class Soup) скрыт внутри базовых UI-компонентов в директории `src/components/ui`.
3.  **Flexibility (Гибкость):** Компоненты поддерживают переопределение стилей через проп `className` с использованием утилиты `tailwind-merge`, что позволяет безопасно накладывать контекстные стили поверх базовых.

### 5.7.2. Технологический стек
*   **Styling:** Tailwind CSS (Utility-first framework).
*   **Logic:** `clsx` (условный рендеринг классов) + `tailwind-merge` (разрешение конфликтов стилей).
*   **Icons:** Lucide React (набор SVG иконок).
*   **Graphics:** Кастомный векторный SVG компонент для логотипа.

### 5.7.3. Структура компонентов (Atomic Levels)

**1. Атомы (src/components/ui):**
Базовые строительные блоки, которые нельзя разбить на части.
*   **Logo:** Векторный компонент логотипа (Coati) с поддержкой масштабирования через `width/height` и `viewBox`.
*   **Button:** Универсальная кнопка с вариантами (`primary`, `ghost`, `outline`) и размерами (`sm`, `md`, `icon`).
*   **Input:** Поле ввода с единым стилем фокуса (Blue-500 ring) и валидации.
*   **Card:** Контейнер с белым фоном, скруглением `rounded-xl`, тонкой обводкой и мягкой тенью.

**2. Молекулы:**
Сочетания атомов для выполнения одной функции.
*   *Пример:* Форма создания проекта (Input + Label + Button внутри Card).
*   *Пример:* Элемент списка требований (Icon + Title + Badge + Meta info).

**3. Организмы:**
Сложные самостоятельные части интерфейса.
*   **Layout:** Глобальная обертка страницы, содержащая Header с Логотипом и навигацией.
*   **ProjectList:** Сетка карточек проектов.

### 5.7.4. Утилита `cn` (Classnames)
Для управления стилями используется хелпер `src/lib/utils.ts`:
```typescript
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
```
Это позволяет писать компоненты так: `<Button className={cn("bg-red-500", className)} />`, гарантируя, что переданный снаружи класс корректно заменит стандартный.

### 5.7.5. Визуальный язык (Visual Identity)

*   **Цветовая палитра:**
    *   **Primary:** `Blue-600` (Активные действия, акценты).
    *   **Background:** `Gray-50` (Фон приложения), `White` (Фон карточек).
    *   **Text:** `Gray-900` (Заголовки), `Gray-500` (Второстепенный текст).
    *   **Decorators:** `Indigo-50` / `Blue-50` (Подложки для иконок).
*   **Типографика:**
    *   Шрифт: Sans-serif (системный стек).
    *   Скругления: `rounded-xl` для крупных блоков, `rounded-lg` для контролов.
*   **Логотип:**
    *   Стилизованное векторное изображение енота (Coati).
    *   Цвета логотипа: Градиенты (Teal/Grey), акценты (Brown/Black).
    *   Используется в Header как основной элемент брендинга.

---

# Раздел 6. Бизнес-процессы (n8n Workflows)

Архитектура бэкенда построена на базе платформы автоматизации n8n, которая выполняет роль API Gateway, Оркестратора бизнес-логики и Интегратора ИИ-сервисов. Все запросы от Frontend поступают на Webhook-ноды n8n.

## 6.1. API Gateway и Роутинг

Единая точка входа для всех клиентских запросов.

*   **Main Router Workflow:**
    *   **Trigger:** `POST /api/v1/*` (Catch-all webhook).
    *   **Auth Middleware:**
        1.  Извлекает `Bearer Token` из заголовка `Authorization`.
        2.  Валидирует JWT (проверка подписи и срока действия).
        3.  Если токен невалиден (и запрос не на `/login`/`/register`) — возвращает статус `401 Unauthorized`.
        4.  Если валиден — извлекает `user_id` и передает дальше.
    *   **Route Switch:** На основе URL перенаправляет запрос в соответствующий Sub-workflow:
        *   `/auth/*` -> **Auth Workflow**
        *   `/projects/*` -> **Project Workflow**
        *   `/ai/*` -> **AI Engine Workflow**
        *   `/files/*` -> **File Workflow**

## 6.2. Аутентификация и Пользователи (Auth Workflow)

Обрабатывает регистрацию, вход и управление доступом.

*   **POST /auth/register:**
    1.  Проверяет уникальность Email в коллекции `Users` (ArangoDB).
    2.  Хеширует пароль (используя ноду Crypto / Argon2).
    3.  Создает новый документ пользователя в БД.
    4.  Генерирует JWT токен.
    5.  Возвращает токен и профиль пользователя.
*   **POST /auth/login:**
    1.  Ищет пользователя по Email.
    2.  Сверяет хеш пароля.
    3.  Если успешно — генерирует и возвращает JWT.
*   **POST /auth/invite:**
    1.  Проверяет права (Requester должен иметь роль `owner` в проекте).
    2.  Создает документ в коллекции `Invites` (генерирует уникальный токен).
    3.  Отправляет Email приглашенному (через SMTP или API почтового сервиса) со ссылкой активации.
*   **POST /auth/accept-invite:**
    1.  Ищет инвайт по токену.
    2.  Проверяет срок действия.
    3.  Создает ребро `MemberOf` между пользователем и проектом.
    4.  Удаляет использованный инвайт.

## 6.3. Управление Данными (Project Workflow)

CRUD операции для основных сущностей системы.

*   **CRUD Projects & Stages:**
    *   **Create Project:** Создает проект и автоматически генерирует дефолтный набор этапов (Stages) на основе системного шаблона.
    *   **Update Stage Order:** При изменении порядка этапов (Drag&Drop) обновляет поле `order` у всех затронутых этапов.
    *   **Delete Stage:** Проверяет наличие данных. Если пусто — удаляет. Если есть данные — возвращает ошибку или требует флага `force`.
*   **CRUD Documents:**
    *   **Get Document:** Возвращает документ и дерево его требований (Requirements), собранное через графовый запрос (AQL Traversal).
    *   **Patch Requirement:** Обновляет контент конкретного блока (получая JSON от TipTap). Обновляет метаданные `updated_at`.

## 6.4. AI Engine и RAG (Ядро Системы)

Центральный процесс, управляющий взаимодействием с LLM.

*   **POST /ai/process-step:**
    *   **Входные данные:** `project_id`, `stage_id`, `step_id`, `user_input`, `context_strategy` (параметр, выбранный пользователем: `full` или `rag`).
    *   **Step Loader:** Загружает конфигурацию текущего шага из массива `steps` коллекции `Stages`.
    *   **Context Build & Check:** Вызывает Sub-workflow `Context Builder`.
        *   *Если вернулась ошибка лимита:* Возвращает на Frontend статус `409 Conflict` с данными о превышении, предлагая пользователю выбор.
    *   **Type Switch:** Если контекст в порядке, выбирает ветку логики в зависимости от `step.type`:
        *   **`ambiguity_loop`:** Анализ неопределенностей или проверка ответов.
        *   **`simple_generation`:** Генерация документа и сохранение в БД.
        *   **`compliance_check`:** Сравнение исходника и результата.
    *   **Logging:** Записывает транзакцию в `Iterations`.

*   **Sub-workflow: Context Builder (Interactive Strategy):**
    1.  **Assembly:** Собирает полный контекст (Текст + Файлы + История).
    2.  **Token Calculation:** Считает точное количество токенов (через библиотеку `tiktoken` в Function Node).
    3.  **Limit Check:** Сравнивает с `context_window` модели.
    4.  **Decision Logic:**
        *   **Case A (Превышение):** Возвращает ошибку `TokenLimitExceeded`.
            *   *Frontend Action:* Показывает модальное окно: "Контекст переполнен (150%). Выберите действие: 1) Включить RAG (авто-сжатие), 2) Сократить вручную, 3) Отмена".
        *   **Case B (Норма или `context_strategy='rag'`):**
            *   Если выбран режим `rag` (или пользователь согласился на него): Выполняет **Vector Search** в ArangoDB, отбирая только релевантные фрагменты.
            *   Если режим `full`: Оставляет контекст как есть.
    5.  **Output:** Готовый промпт для отправки в LLM.

## 6.5. Обработка Файлов (File Workflow)

*   **POST /files/upload:**
    *   **Input:** Binary Data (Multipart Form).
    *   **Processing:**
        1.  Сохраняет файл (в S3 или локальную папку).
        2.  **Text Extraction:** Извлекает текст из PDF/DOCX (используя библиотеки типа `pdf-parse`).
        3.  **Embedding Generation:** Генерирует векторные представления (Embeddings) для извлеченного текста (через OpenAI API или локальную модель).
    *   **Database:**
        1.  Создает документ в `Attachments` с полями `parsed_text` и `size_tokens`.
        2.  Сохраняет векторы в индекс ArangoDB (для работы RAG).
    *   **Output:** Возвращает ID файла и его размер в токенах для отображения в UI.

**ArangoDB — это полноценная векторная база данных** (начиная с версии 3.10).

**Как это работает:**
1.  Вы сохраняете вектор (массив чисел, например `[0.12, -0.5, ...]`) как обычное поле в документе.
2.  В ArangoDB создается специальный тип индекса — **ArangoSearch View** с поддержкой векторного поиска (или прямой **Vector Index** в новых версиях).
3.  Вы можете выполнять AQL-запросы, которые комбинируют:
    *   Графовый поиск (найти связи).
    *   Фильтрацию по метаданным (найти документы проекта X).
    *   Векторную близость (найти похожие по смыслу тексты).

**Почему это круто для нашего проекта:**
Нам не нужно поднимать отдельную базу (типа Pinecone, Milvus или Qdrant) только для векторов. Мы храним всё (пользователей, графы требований и векторы для RAG) в одной ArangoDB. Это упрощает инфраструктуру (Docker Compose) и поддержку.

---

# Раздел 7. Roadmap Реализации

План реализации с приоритетом на создание полноценного UX (Split View) уже в первой версии.

## Этап 1: MVP Core (Фундамент и Рабочий Процесс)
*Цель: Реализовать полный цикл работы одного пользователя с удобным интерфейсом уточнения.*

1.  **Инфраструктура:**
    *   **Docker Compose:**
        *   `arangodb` (База данных).
        *   `n8n` (Бэкенд/Логика).
        *   `nginx` (Веб-сервер для раздачи React-фронтенда и проксирования API).
2.  **База Данных:**
    *   Инициализация полной схемы из **Раздела 3**:
        *   Создание всех Document Collections (`Users`, `Projects`, `Stages`, `Documents`, `Requirements`, `Dictionaries`, `Prompts`, `AI_Models`, `Iterations`).
        *   Создание всех Edge Collections (`MemberOf`, `Structure`, `Traceability`, `DocLink`).
        *   Заполнение `Dictionaries` базовыми значениями.
3.  **Backend (n8n):**
    *   **Auth:** Регистрация и Логин (JWT).
    *   **Project:** Создание проекта и чтение структуры.
    *   **AI Engine:** Реализация логики `Ambiguity Check` и `Simple Generation`.
4.  **Frontend (React):**
    *   **Design System (Atomic UI):**
        *   Внедрение методологии Atomic Design на базе Tailwind CSS.
        *   Разработка библиотеки базовых компонентов-атомов (`Button`, `Input`, `Card`, `Logo`) с инкапсуляцией стилей.
        *   Настройка утилит для управления классами (`clsx`, `tailwind-merge`).
    *   **Layout:** Реализация основной компоновки (Навигация, Рабочая зона, Сайдбар) с использованием компонентов дизайн-системы.
    *   **Editor:** Подключение TipTap (пока без сложных контейнеров, но с поддержкой Highlights).
    *   **Q&A Split View:**
        *   Реализация разделенного экрана.
        *   Логика подсветки текста в редакторе по совпадению с вопросом.
        *   Форма ответов (без цитирования в карточке, только вопрос и инпут).

## Этап 2: Атомарность, Файлы и RAG
*Цель: Углубление функциональности редактора и работа с контекстом.*

1.  **Backend:**
    *   **Files:** Загрузка, парсинг, создание Embeddings.
    *   **RAG:** Реализация логики `Context Builder` с векторным поиском.
    *   **Compliance:** Добавление шага сверки (Diff Report).
2.  **Frontend:**
    *   **Editor 2.0:** Реализация кастомных узлов "Требование-Контейнер". Визуализация ID (`BR-001`).
    *   **Files UI:** Drag & Drop зона и Token Meter (с логикой выбора стратегии при переполнении).

## Этап 3: SaaS и Управление (Collaboration)
*Цель: Многопользовательский режим и гибкая настройка.*

1.  **Backend:**
    *   Система инвайтов (Email, Tokens).
    *   Middleware проверки ролей (`editor`/`reader`).
    *   CRUD для управления этапами (Drag & Drop, Add/Delete).
2.  **Frontend:**
    *   Настройки проекта (Workflow Editor).
    *   Управление командой.
    *   Профиль пользователя и Админка.

## Этап 4: Полировка (Polish & Scale)
*Цель: Вспомогательные функции.*

1.  **Git Export:** Генерация Markdown и коммит в репозиторий.
2.  **Analytics:** Сбор статистики по промптам.
3.  **Traceability UI:** Визуализация связей между требованиями.

---

# Прогресс

### 1. Инфраструктура и Бэкенд (n8n + ArangoDB)
Мы развернули серверную часть, работающую по принципу **Low-Code Backend**.

*   **Docker Environment:**
    *   Настроен `docker-compose.yml`, поднимающий связку: `arangodb` (БД) + `n8n` (Логика) + `nginx` (Веб-сервер).
*   **База Данных (ArangoDB):**
    *   Инициализированы коллекции документов: `Projects` (Проекты) и `Requirements` (Требования).
*   **API Logic (n8n Workflows):**
    *   Создано 4 рабочих сценария (Workflow) для реализации CRUD-операций:
        1.  `GET /projects` — Получение списка проектов (AQL запрос).
        2.  `POST /projects` — Создание нового проекта.
        3.  `GET /requirements` — Получение требований конкретного проекта (фильтр по `projectId`).
        4.  `POST /requirements` — Добавление требования в проект.
    *   Настроены **Webhook Nodes** для приема HTTP-запросов от фронтенда.
    *   Настроены **ArangoDB Nodes** для выполнения запросов к базе.

---

### 2. Архитектура Фронтенда (React + Atomic Design)
Мы полностью переработали архитектуру стилей, уйдя от "CSS-лапши" к профессиональному компонентному подходу.

*   **Технологический стек:** Vite, React, TypeScript, Tailwind CSS, Axios, React Router DOM.
*   **Дизайн-система (Atomic UI):**
    *   Внедрена методология **Atomic Design**.
    *   Реализован подход **"Clean JSX"**: стили инкапсулированы внутри компонентов, а не разбросаны по страницам.
    *   Подключены утилиты `clsx` и `tailwind-merge` (функция `cn`) для умного объединения классов и разрешения конфликтов стилей.
*   **Библиотека компонентов (`src/components/ui`):**
    *   **Button:** Универсальная кнопка с поддержкой вариантов (`primary`, `ghost`, `outline`) и размеров.
    *   **Input:** Поле ввода с единым стилем фокуса и состояний.
    *   **Card:** Базовый контейнер (белая подложка, тень, скругление) для построения интерфейса.
    *   **Logo:** Кастомный SVG-компонент с векторным логотипом (енот/коати), оптимизированный для React (корректный `viewBox`, camelCase атрибуты).

---

### 3. Реализованный Функционал (User Flow)
На данный момент работает полный цикл создания и просмотра данных:

1.  **Глобальный Layout:**
    *   Шапка с логотипом и навигацией.
    *   Адаптивная верстка (центрирование, отступы).
2.  **Страница "Список проектов" (`/`):**
    *   Отображение сетки проектов (Grid Layout).
    *   Форма создания нового проекта (использует UI-компоненты).
    *   Интеграция с API: данные реально сохраняются в ArangoDB и загружаются оттуда.
    *   Обработка состояний загрузки (Loader) и пустого списка.
3.  **Страница "Детали проекта" (`/project/:id`):**
    *   Роутинг: переход по клику на карточку проекта.
    *   Отображение списка требований внутри проекта.
    *   Форма добавления нового требования.
    *   Визуализация статусов требований (New, In Progress, Done).

---

### 4. Ключевые файлы проекта

Вот как выглядит структура того, что мы написали:

```text
frontend/
├── src/
│   ├── api.ts                  # Клиент Axios, типизация (Project, Requirement)
│   ├── lib/
│   │   └── utils.ts            # Утилита cn() для стилей
│   ├── components/
│   │   ├── Layout.tsx          # Общая обертка страниц
│   │   └── ui/                 # Атомы дизайн-системы
│   │       ├── Button.tsx
│   │       ├── Card.tsx
│   │       ├── Input.tsx
│   │       └── Logo.tsx        # Векторный логотип
│   ├── pages/
│   │   ├── ProjectsPage.tsx    # Список проектов + Создание
│   │   └── ProjectDetailsPage.tsx # Требования проекта + Создание
│   ├── index.css               # Базовые директивы Tailwind
│   └── main.tsx                # Роутинг и точка входа
└── vite.config.ts              # Настройка прокси к n8n
```

### ✅ Что уже сделано (Фундамент)

Мы подготовили почву для разработки сложного функционала, чтобы дальше не отвлекаться на настройку среды и стилей.

**1. Инфраструктура и База Данных**
*   **Docker Environment:** Подняты контейнеры `arangodb` и `n8n`.
*   **Базовая схема БД:** Созданы коллекции `Projects` и `Requirements` для старта.
*   **Связь:** Настроен прокси (Vite) для общения фронтенда с бэкендом без CORS-проблем в dev-режиме.

**2. Бэкенд (n8n - Basic CRUD)**
*   Реализованы базовые сценарии (Workflows) для управления проектами и требованиями:
    *   Создание и чтение проектов.
    *   Создание и чтение требований внутри проекта.

**3. Фронтенд (Архитектура и Дизайн-система)**
*   **Atomic Design:** Внедрена компонентная архитектура (папка `src/components/ui`).
*   **UI Kit:** Реализованы атомы: `Button`, `Input`, `Card`, `Logo` (векторный).
*   **Стилизация:** Настроен Tailwind CSS + `clsx`/`tailwind-merge` для чистого кода.
*   **Роутинг и API:** Настроены переходы между страницами и типизированный клиент `axios`.
*   **Верстка:** Готовы экраны "Список проектов" и "Детали проекта" (пока с простыми текстовыми полями).

---

### 🚧 Что осталось реализовать в рамках Этапа 1

Согласно **Разделу 7**, для завершения этапа "MVP Core" нам нужно внедрить ключевые механики работы с текстом и структуру данных.

**1. База Данных (Расширение схемы)**
*   [ ] Инициализация полной схемы из Раздела 3 (коллекции `Users`, `Documents`, `Dictionaries` и др.).
*   [ ] Создание ребер (Edge Collections) для связей: `Structure` (иерархия), `Traceability`.

**2. Бэкенд (n8n)**
*   [ ] **Auth:** Реализация регистрации и логина (JWT).
*   [ ] **AI Engine:** Логика `Ambiguity Check` (проверка на неоднозначность) и `Simple Generation` (генерация требований).

**3. Фронтенд (Ключевой UX)**
*   [ ] **Editor (TipTap):** Замена обычных `textarea` на Rich Text Editor (TipTap). Поддержка форматирования и выделения текста (Highlights).
*   [ ] **Q&A Split View:**
    *   Реализация разделенного экрана (Редактор слева / Панель AI справа).
    *   Логика подсветки текста в редакторе при клике на вопрос.
    *   Интерфейс чата/ответов на вопросы AI.
*   [ ] **Nginx:** Настройка веб-сервера для продакшн-сборки (сейчас работаем через Vite dev server).

---

**Резюме:** У нас есть "скелет" приложения и дизайн-система. Теперь нужно наращивать "мясо": внедрять **TipTap редактор** и **Split View** — это приоритет №1 для следующего шага.
