# Technical Patch v2.1 (DIFF/PATCH)
**Target:** `docs/progress/20251217_architecture-v2-FINAL.md`
**Scope:** –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ —Ç–æ—á–µ—á–Ω—ã–µ –ø—Ä–∞–≤–∫–∏. –ù–µ –ø–µ—Ä–µ–ø–∏—Å—ã–≤–∞—Ç—å –¥–æ–∫—É–º–µ–Ω—Ç —Ü–µ–ª–∏–∫–æ–º.

---

## PATCH-0 ‚Äî Terminology Fix (Header)
**–ü—Ä–æ–±–ª–µ–º–∞:** –≤ v2.0 –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è pessimistic locking, –Ω–æ –Ω—É–∂–µ–Ω CAS (optimistic token) –¥–ª—è –∞—Ç–æ–º–∞—Ä–Ω–æ—Å—Ç–∏.

### Change
**ADD** —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ –±–ª–æ–∫–∞ ‚Äú–ü—Ä–∏–Ω—è—Ç—ã–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–∏–µ —Ä–µ—à–µ–Ω–∏—è‚Äù:
```md
- **Concurrency (v2.1):** Pessimistic UX + **Optimistic CAS** –Ω–∞ –∑–∞–ø–∏—Å–∏ (`_rev` / If-Match) –¥–ª—è –∞—Ç–æ–º–∞—Ä–Ω–æ—Å—Ç–∏ lock/merge.
```

---

## PATCH-1 ‚Äî Section 1 (Schema)

### PATCH-1.1 ‚Äî Atoms: `_rev` –∫–∞–∫ concurrency token (–Ω–æ—Ä–º–∞—Ç–∏–≤–Ω–æ–µ –ø—Ä–∏–º–µ—á–∞–Ω–∏–µ)
**ADD** –≤ –ø–æ–¥—Ä–∞–∑–¥–µ–ª `2.3. atoms` –ø–æ—Å–ª–µ –æ–ø–∏—Å–∞–Ω–∏—è –ø–æ–ª–µ–π `locked_by/locked_until`:
```md
**üß∑ Concurrency Token (v2.1):**
ArangoDB –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤–µ–¥–µ—Ç –ø–æ–ª–µ `_rev` –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞.

- UI **–æ–±—è–∑–∞–Ω** –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å `_rev` –∫–∞–∫ CAS-—Ç–æ–∫–µ–Ω.
- –õ—é–±—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ `lock/unlock/merge/archive` –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω—ã –∫–∞–∫ CAS (If-Match ‚Üí `_rev`) —á—Ç–æ–±—ã –∏—Å–∫–ª—é—á–∏—Ç—å lock-stealing –∏ –¥–≤–æ–π–Ω–æ–π merge.
- Backend (n8n) –¥–æ–ª–∂–µ–Ω –º–∞–ø–ø–∏—Ç—å –∫–æ–Ω—Ñ–ª–∏–∫—Ç `_rev` –≤ HTTP `409 CONFLICT`.
```

### PATCH-1.2 ‚Äî structure_links: –∑–∞–ø—Ä–µ—Ç `docs -> atoms`
**REPLACE** –≤ –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ `3.1 structure_links` —Å–ø–∏—Å–æ–∫ –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π:
```md
- **–û—Ç–∫—É–¥–∞ (`_from`):** `docs/*`, `sections/*`
- **–ö—É–¥–∞ (`_to`):** `sections/*`, `atoms/*`
```
**WITH**:
```md
- **–û—Ç–∫—É–¥–∞ (`_from`):** `docs/*`, `sections/*`
- **–ö—É–¥–∞ (`_to`):**
  - `docs/*` ‚Üí **—Ç–æ–ª—å–∫–æ** `sections/*`
  - `sections/*` ‚Üí `sections/*` | `atoms/*`

**v2.1 Constraint:** –ø—Ä—è–º—ã–µ —Å–≤—è–∑–∏ `docs/* -> atoms/*` –∑–∞–ø—Ä–µ—â–µ–Ω—ã (–∏–Ω–∞—á–µ baseline traversal —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –Ω–µ–æ–¥–Ω–æ–∑–Ω–∞—á–Ω—ã–º).
```

### PATCH-1.3 ‚Äî artifacts(ai_error): `error_code`/`error_details.raw_response` –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã
–í v2.0 –ø–æ–ª–µ —É–∂–µ –æ–ø–∏—Å–∞–Ω–æ, –Ω–æ –Ω–µ –ø–æ–º–µ—á–µ–Ω–æ –∫–∞–∫ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ.

**ADD** –≤ `2.4 artifacts` –ø–æ—Å–ª–µ –±–ª–æ–∫–∞ `error_details`:
```md
**v2.1 Constraint (ai_error):**
–î–ª—è `type="ai_error"` –ø–æ–ª—è `error_code`, `error_message`, `error_details.request_id`, `error_details.raw_response` —è–≤–ª—è—é—Ç—Å—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–º–∏.
```

---

## PATCH-2 ‚Äî Section 2 (API)

### PATCH-2.1 ‚Äî –û–±—â–∏–µ –ø—Ä–∞–≤–∏–ª–∞: If-Match + 409/423
**ADD** –≤ `2.1 –û–±—â–∏–µ –ø—Ä–∏–Ω—Ü–∏–ø—ã`:
```md
- **Optimistic Concurrency (v2.1):**
  - –î–ª—è mutation endpoints –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∑–∞–≥–æ–ª–æ–≤–æ–∫ `If-Match: <_rev>`.
  - –ï—Å–ª–∏ `_rev` –Ω–µ —Å–æ–≤–ø–∞–ª ‚Üí `409 CONFLICT`.
  - –ï—Å–ª–∏ —Ä–µ—Å—É—Ä—Å –ª–æ–≥–∏—á–µ—Å–∫–∏ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –¥—Ä—É–≥–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º ‚Üí `423 LOCKED`.
```

### PATCH-2.2 ‚Äî GET /documents/:doc_id/structure: –≤–µ—Ä–Ω—É—Ç—å —Ä–µ–≤–∏–∑–∏–∏
**PATCH** –≤ –æ—Ç–≤–µ—Ç–µ `GET /documents/:doc_id/structure` –¥–ª—è item —Ç–∏–ø–∞ `atom` –¥–æ–±–∞–≤–∏—Ç—å:
```json
{
  "atom_rev": "_rev_from_atoms",
  "structure_edge_id": "structure_links/<edgeKey>",
  "structure_edge_rev": "_rev_from_structure_edge"
}
```
**NOTE:** `structure_edge_*` –æ—Ç–Ω–æ—Å–∏—Ç—Å—è –∫ —Ä–µ–±—Ä—É `contains`, –∫–æ—Ç–æ—Ä–æ–µ –¥–µ—Ä–∂–∏—Ç –∞—Ç–æ–º –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ (–¥–ª—è CAS –ø—Ä–∏ merge/archive).

### PATCH-2.3 ‚Äî POST /atoms/:atom_id/lock: –¥–æ–±–∞–≤–∏—Ç—å If-Match –∏ 409/423
**PATCH** endpoint `POST /atoms/:atom_id/lock`:

**Request Headers:**
```
If-Match: <atom._rev>
```

**Response (Success):**
```json
{
  "success": true,
  "locked_until": "2023-12-17T15:35:00Z",
  "atom_rev": "new_rev"
}
```

**Response (Locked by another user) ‚Üí 423:**
```json
{
  "error": "LOCKED",
  "message": "Atom is locked by user_456 until 2023-12-17T15:30:00Z",
  "locked_by": "user_456",
  "locked_until": "2023-12-17T15:30:00Z"
}
```

**Response (Revision conflict) ‚Üí 409:**
```json
{
  "error": "REV_CONFLICT",
  "message": "Atom was modified concurrently. Refresh and retry."
}
```

### PATCH-2.4 ‚Äî POST /atoms/:atom_id/unlock: If-Match + owner check
**PATCH** endpoint `POST /atoms/:atom_id/unlock`:

**Request Headers:**
```
If-Match: <atom._rev>
```

**Request Body:**
```json
{ "user_id": "user_123" }
```

**Errors:**
- `423 LOCKED` –µ—Å–ª–∏ `locked_by != user_id`.
- `409 CONFLICT` –µ—Å–ª–∏ `_rev` –Ω–µ —Å–æ–≤–ø–∞–ª.

### PATCH-2.5 ‚Äî POST /proposals/:proposal_atom_id/merge: CAS –ø–æ structure edge
**PATCH** –∫–æ–Ω—Ç—Ä–∞–∫—Ç:

**Request Headers:**
```
If-Match: <structure_edge_rev>
```

**Request Body (v2.1):**
```json
{
  "target_active_atom_id": "atom_uuid_v5",
  "structure_edge_id": "structure_links/<edgeKey>",
  "user_id": "user_123",
  "allow_outdated": false
}
```

**Errors:**
- `409 CONFLICT` –µ—Å–ª–∏ structure edge `_rev` –Ω–µ —Å–æ–≤–ø–∞–ª (–∫—Ç–æ-—Ç–æ —É–∂–µ —Å–º–µ—Ä–∂–∏–ª/–ø–µ—Ä–µ–∫–ª—é—á–∏–ª —Å—Ç—Ä—É–∫—Ç—É—Ä—É).
- `423 LOCKED` –µ—Å–ª–∏ –∞—Ç–æ–º –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –¥—Ä—É–≥–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º.
- `400 BAD_REQUEST` –µ—Å–ª–∏ proposal –Ω–µ —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ target, –ª–∏–±–æ proposal —É–∂–µ –Ω–µ status=proposal.

---

## PATCH-3 ‚Äî Section 3 (Workflows / AQL) ‚Äî CRITICAL

### PATCH-3.6.1 ‚Äî Lock Atom (CAS + no lock stealing)
**REPLACE** –∞–ª–≥–æ—Ä–∏—Ç–º `3.6.1 Lock Atom` —Ü–µ–ª–∏–∫–æ–º –Ω–∞:
```aql
LET atom_id = @atom_id
LET user_id = @user_id
LET expected_rev = @expected_rev // from If-Match
LET now = DATE_NOW()
LET new_until = DATE_ADD(now, 5, 'minutes')

LET atom = DOCUMENT(CONCAT('atoms/', atom_id))

// 1) –ï—Å–ª–∏ —É–∂–µ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –∏ –Ω–µ –∏—Å—Ç–µ–∫–ª–æ ‚Äî 423
FILTER !(atom.locked_by != null AND atom.locked_until > now)

// 2) CAS update –ø–æ _rev (–∏—Å–∫–ª—é—á–∞–µ—Ç –≥–æ–Ω–∫—É)
LET updated = FIRST(
  FOR a IN atoms
    FILTER a._key == atom_id
    FILTER a._rev == expected_rev
    UPDATE a WITH {
      locked_by: user_id,
      locked_until: new_until
    } IN atoms OPTIONS { ignoreRevs: false }
    RETURN NEW
)

RETURN updated != null
  ? { success: true, locked_until: updated.locked_until, atom_rev: updated._rev }
  : { error: "REV_CONFLICT" }
```

**n8n mapping:**
- –ï—Å–ª–∏ –≤–µ—Ä–Ω—É–ª—Å—è `{error:"REV_CONFLICT"}` ‚Üí HTTP 409.
- –ï—Å–ª–∏ —É–ø–∞–ª–∏ –Ω–∞ –ø–µ—Ä–≤–æ–º FILTER (locked –¥—Ä—É–≥–∏–º) ‚Üí HTTP 423.

### PATCH-3.6.2 ‚Äî Unlock Atom (owner check + CAS)
**REPLACE** `3.6.2 Unlock Atom` –Ω–∞:
```aql
LET atom_id = @atom_id
LET user_id = @user_id
LET expected_rev = @expected_rev
LET atom = DOCUMENT(CONCAT('atoms/', atom_id))

// –¢–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª–µ—Ü –º–æ–∂–µ—Ç —Å–Ω—è—Ç—å
FILTER atom.locked_by == null OR atom.locked_by == user_id

LET updated = FIRST(
  FOR a IN atoms
    FILTER a._key == atom_id
    FILTER a._rev == expected_rev
    UPDATE a WITH { locked_by: null, locked_until: null } IN atoms OPTIONS { ignoreRevs: false }
    RETURN NEW
)

RETURN updated != null
  ? { success: true, atom_rev: updated._rev }
  : { error: "REV_CONFLICT" }
```

### PATCH-3.2 ‚Äî Merge Proposal (CAS –ø–æ structure edge + orphan prevention)
**REPLACE** `3.2 Merge Proposal` AQL —Ü–µ–ª–∏–∫–æ–º –Ω–∞:
```aql
LET winner_id = @winner_proposal_id
LET current_id = @current_active_id
LET user_id = @user_id
LET structure_edge_id = @structure_edge_id // "structure_links/<key>"
LET expected_edge_rev = @expected_edge_rev // from If-Match
LET allow_outdated = @allow_outdated
LET now = DATE_NOW()

LET current_atom = DOCUMENT(CONCAT('atoms/', current_id))
LET winner_atom = DOCUMENT(CONCAT('atoms/', winner_id))
LET edge = DOCUMENT(structure_edge_id)

// 0) –ë—ã—Å—Ç—Ä—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏
FILTER current_atom != null AND winner_atom != null AND edge != null

// 1) Lock check
FILTER current_atom.locked_by == null OR current_atom.locked_by == user_id

// 2) Status checks
FILTER current_atom.status == "active"
FILTER winner_atom.status == "proposal"

// 3) Edge must currently point to current atom (prevents stale merge)
FILTER edge._to == CONCAT('atoms/', current_id)

// 4) Winner must be a proposal for current atom
LET winner_prop_edge = FIRST(
  FOR pe IN proposal_links
    FILTER pe._from == CONCAT('atoms/', winner_id)
    FILTER pe._to == CONCAT('atoms/', current_id)
    RETURN pe
)
FILTER winner_prop_edge != null
FILTER allow_outdated == true OR (winner_prop_edge.outdated != true)

// 5) Switch structure edge using CAS on edge _rev (single-edge update)
LET switched_edge = FIRST(
  FOR e IN structure_links
    FILTER e._id == structure_edge_id
    FILTER e._rev == expected_edge_rev
    UPDATE e WITH { _to: CONCAT('atoms/', winner_id) } IN structure_links OPTIONS { ignoreRevs: false }
    RETURN NEW
)
FILTER switched_edge != null

// 6) Now commit atom status changes
UPDATE current_id WITH { status: "archived", archived_at: now } IN atoms
UPDATE winner_id WITH { status: "active", activated_at: now } IN atoms

// 7) Revision link
INSERT {
  _from: CONCAT('atoms/', winner_id),
  _to: CONCAT('atoms/', current_id),
  type: "replaces",
  created_at: now
} INTO revision_links

// 8) Rebase other proposals that were pointing to current atom
LET rebased = (
  FOR pe IN proposal_links
    FILTER pe._to == CONCAT('atoms/', current_id)
    FILTER pe._from != CONCAT('atoms/', winner_id)
    UPDATE pe WITH {
      _to: CONCAT('atoms/', winner_id),
      outdated: true,
      rebased_from: CONCAT('atoms/', current_id),
      rebased_at: now
    } IN proposal_links
    RETURN { id: pe._from, outdated: true }
)

// 9) Remove winner's proposal link (it is no longer a proposal)
FOR pe IN proposal_links
  FILTER pe._from == CONCAT('atoms/', winner_id)
  REMOVE pe IN proposal_links

RETURN {
  success: true,
  new_active_atom_id: winner_id,
  archived_atom_id: current_id,
  structure_edge_id: structure_edge_id,
  structure_edge_rev: switched_edge._rev,
  rebased_proposals_count: LENGTH(rebased),
  rebased_proposals: rebased
}
```

**Guarantees after patch:**
- –ù–µ–≤–æ–∑–º–æ–∂–µ–Ω ‚Äú–¥–≤–æ–π–Ω–æ–π merge‚Äù –Ω–∞ –æ–¥–∏–Ω —Å–ª–æ—Ç: CAS –ø–æ `_rev` —Ä–µ–±—Ä–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞—ë—Ç 409.
- –ù–µ–≤–æ–∑–º–æ–∂–µ–Ω `active` orphan: —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø–µ—Ä–µ–∫–ª—é—á–∞–µ—Ç—Å—è —Å—Ç—Ä–æ–≥–æ –æ–¥–Ω–∏–º edge –¥–æ —Å—Ç–∞—Ç—É—Å–æ–≤, –∏ –≤—Å—è –æ–ø–µ—Ä–∞—Ü–∏—è –≤ –æ–¥–Ω–æ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏.

### PATCH-3.3 ‚Äî Create Baseline (recursive traversal, docs->atoms banned)
**REPLACE** `3.3 Create Baseline` –∞–ª–≥–æ—Ä–∏—Ç–º —Ü–µ–ª–∏–∫–æ–º –Ω–∞:
```aql
LET doc_id = @doc_id
LET now = DATE_NOW()

// 0) Validation: forbid docs -> atoms
LET illegal = (
  FOR e IN structure_links
    FILTER e._from == doc_id
    FILTER LIKE(e._to, "atoms/%")
    RETURN e
)
FILTER LENGTH(illegal) == 0

// 1) Create baseline node
LET b = INSERT {
  doc_id: doc_id,
  tag: @version_tag,
  title: @title,
  frozen_at: now
} INTO baselines RETURN NEW

// 2) Traverse recursively doc -> ... -> atoms
LET snap = (
  FOR v, e, p IN 1..10 OUTBOUND doc_id structure_links
    FILTER IS_SAME_COLLECTION("atoms", v)
    FILTER v.status == "active"

    LET lastEdge = p.edges[-1]

    INSERT {
      _from: b._id,
      _to: v._id,
      order: lastEdge.order,
      type: "snapshot_item",
      snapshotted_at: now
    } INTO baseline_items

    RETURN v._id
)

RETURN { baseline_id: b._id, items_snapshotted: LENGTH(snap), frozen_at: b.frozen_at }
```

---

## PATCH-4 ‚Äî Validation Logic: Single Parent Invariant

### PATCH-4.1 ‚Äî Add new subsection (recommendation) in Validation Checklist
**ADD** –≤ –∫–æ–Ω—Ü–µ Validation Checklist (–†–∞–∑–¥–µ–ª 4) –Ω–æ–≤—ã–π –±–ª–æ–∫:

```md
## 4.X. Graph Integrity Validation (v2.1)

### Single Parent Invariant
**Rule:** –∫–∞–∂–¥—ã–π `atoms/*` –º–æ–∂–µ—Ç –∏–º–µ—Ç—å **–Ω–µ –±–æ–ª–µ–µ –æ–¥–Ω–æ–≥–æ** –≤—Ö–æ–¥—è—â–µ–≥–æ `structure_links` —Ä–µ–±—Ä–∞ `type="contains"`.

### Script: Validate Graph
–ó–∞–ø—É—Å—Ç–∏—Ç—å –ø–µ—Ä–µ–¥ —Ä–µ–ª–∏–∑–æ–º –∏ –ø–æ—Å–ª–µ —Å—Ç—Ä–µ—Å—Å-—Ç–µ—Å—Ç–æ–≤.
```

### PATCH-4.2 ‚Äî AQL ‚ÄúValidate Graph‚Äù (—Å–∫—Ä–∏–ø—Ç)
```aql
// 1) Atoms with multiple parents in structure
LET multi_parent_atoms = (
  FOR e IN structure_links
    FILTER e.type == "contains"
    FILTER LIKE(e._to, "atoms/%")
    COLLECT to = e._to WITH COUNT INTO c
    FILTER c > 1
    RETURN { atom: to, parents_count: c }
)

// 2) Proposal atoms without exactly 1 outbound proposal_link
LET proposal_edges = (
  FOR a IN atoms
    FILTER a.status == "proposal"
    LET edges = (
      FOR pe IN proposal_links
        FILTER pe._from == a._id
        RETURN pe
    )
    FILTER LENGTH(edges) != 1
    RETURN { proposal: a._id, proposal_links_count: LENGTH(edges) }
)

// 3) Illegal doc -> atoms edges (must be 0)
LET illegal_doc_to_atom = (
  FOR e IN structure_links
    FILTER LIKE(e._from, "docs/%")
    FILTER LIKE(e._to, "atoms/%")
    RETURN e
)

RETURN {
  ok: LENGTH(multi_parent_atoms) == 0 AND LENGTH(proposal_edges) == 0 AND LENGTH(illegal_doc_to_atom) == 0,
  multi_parent_atoms: multi_parent_atoms,
  bad_proposals: proposal_edges,
  illegal_doc_to_atom: illegal_doc_to_atom
}
```

---

## PATCH-5 ‚Äî Certificate Gate (post-conditions)
**ADD** –≤ —Å–∞–º—ã–π –∫–æ–Ω–µ—Ü –¥–æ–∫—É–º–µ–Ω—Ç–∞ (–ø–æ—Å–ª–µ Summary) –∫–æ—Ä–æ—Ç–∫–∏–π gate:
```md
## Architecture Quality Gate (v2.1)
–°–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç –∫–∞—á–µ—Å—Ç–≤–∞ –º–æ–∂–µ—Ç –±—ã—Ç—å –≤—ã–¥–∞–Ω —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏:
1) Lock/Unlock —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω—ã —á–µ—Ä–µ–∑ CAS (If-Match / `_rev`) –∏ –¥–∞—é—Ç 409/423.
2) Merge –∏—Å–ø–æ–ª—å–∑—É–µ—Ç CAS –ø–æ `structure_links` edge `_rev`.
3) –ó–∞–ø—Ä–µ—â–µ–Ω—ã `docs -> atoms` —Å–≤—è–∑–∏.
4) –°–∫—Ä–∏–ø—Ç Validate Graph –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç `ok: true`.
```

---

–ï—Å–ª–∏ –æ–∫ ‚Äî –≤ —Å–ª–µ–¥—É—é—â–µ–º —Å–æ–æ–±—â–µ–Ω–∏–∏ –¥–∞–º ¬´Certificate of Architecture Quality¬ª (v2.1) –≤ —Ñ–æ—Ä–º–∞—Ç–µ, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–Ω–æ –ø—Ä–∏–ª–æ–∂–∏—Ç—å –∫ —Å–ø–µ–∫–∏ –∫–∞–∫ –æ—Ç–¥–µ–ª—å–Ω—ã–π –∞—Ä—Ç–µ—Ñ–∞–∫—Ç.