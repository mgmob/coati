Ниже — аудит именно **текущей v2.0 спеки** (файл `docs/progress/20251217_architecture-v2-FINAL.md`) на предмет дедлоков/гонок/дыр в контрактах.

## 0) Важное несоответствие термина
В вашем запросе фигурирует «Optimistic Locking в Section 3». В самой спеки v2.0 **реализован Pessimistic Locking через поля `locked_by/locked_until`**, а **оптимистической блокировки через `_rev`/CAS нет**. Это критично, потому что текущий AQL-алгоритм lock/merge **можно обойти гонкой**.

---

## 1) Проверка “Optimistic Locking” / concurrency: неустойчиво, можно обойти
### 1.1. Гонка при `POST /atoms/:id/lock` (lock stealing)
Алгоритм 3.6.1:
```aql
LET atom = DOCUMENT(CONCAT('atoms/', @atom_id))
FILTER atom.locked_by == null OR atom.locked_until < DATE_NOW()
UPDATE @atom_id WITH { locked_by: @user_id, locked_until: locked_until } IN atoms
```
Проблема: два клиента A и B могут **одновременно прочитать один и тот же snapshot**, оба пройти `FILTER`, и затем второй UPDATE перезапишет `locked_by`.

**Почему это реально:** фильтр проверяется до фактической записи; ожидание write-lock не приводит к повторной проверке условия.

**Итог:** блокировку можно «украсть» конкурентным запросом.

### 1.2. Блокировку можно снять чужим пользователем (bypass API)
`Unlock Atom` (3.6.2) делает безусловный:
```aql
UPDATE @atom_id WITH { locked_by: null, locked_until: null } IN atoms
```
Нет проверки `locked_by == @user_id`. Любой, кто знает `atom_id`, может разблокировать.

### 1.3. Самое опасное: merge без реального CAS → возможны два active атома
Сценарий 3.2 `Merge Proposal` проверяет lock:
```aql
LET current_atom = DOCUMENT(CONCAT('atoms/', @current_active_id))
FILTER current_atom.locked_by == null OR current_atom.locked_by == @user_id
```
Но **не проверяет**, что:
- `current_active_id` всё ещё реально стоит в `structure_links` в момент merge,
- `winner_proposal_id` всё ещё `status: proposal`,
- `winner_proposal_id` всё ещё указывает proposal_link’ом на `current_active_id` и не `outdated`.

**Гонка (реальный разрыв целостности):**
- Merge#1: A→P1 успешно переключил `structure_links` на P1 и ребейзнул P2 на P1.
- Merge#2 параллельно (всё ещё с параметрами `current_active_id=A`, `winner=P2`):
  - заархивирует A повторно,
  - сделает P2 `active`,
  - не найдёт ни одного `structure_links` на A (они уже на P1),
  - удалит proposal_link P2→P1,
  - в итоге **P2 станет `active`, но не будет в структуре (orphan active)**, а в структуре останется P1 `active`.

Это прямое нарушение инварианта “одна активная версия в документе”.

### 1.4. Дедлоки/конфликты на уровне БД
Скорее не классические deadlock’и, а **write-write conflicts** при параллельных merge/archive/baseline:
- Merge пишет `atoms`, `structure_links`, `revision_links`, `proposal_links`.
- Archive пишет `atoms`, `structure_links`.
- Baseline пишет `baselines`, `baseline_items`, читает `structure_links`.

ArangoDB обычно вернёт конфликт/ошибку транзакции или будет сериализовывать. Спека **не описывает retry policy** в n8n (сколько раз и с какой задержкой повторять транзакцию при конфликте). Это логический gap.

### Что нужно, чтобы стало «robust» (рекомендация)
1) **Настоящая optimistic locking (CAS) через `_rev`**:
- в ответе `GET /documents/.../structure` уже можно отдавать `_rev` для atom;
- `POST /atoms/:id/lock` должен принимать `expected_rev` и делать `UPDATE ... OPTIONS { ignoreRevs: false }`.

2) **Unlock**: разрешить только владельцу:
- `FILTER atom.locked_by == @user_id`.

3) **Merge**: сделать “compare-and-swap” на уровне структуры:
- обновление `structure_links` должно быть строго **1 edge updated**, иначе abort (конфликт).
- дополнительно: `FILTER winner.status == 'proposal'` и наличие proposal_link именно на `current_active_id`.

4) **Retry policy в n8n** для транзакций (например 3 попытки с backoff 50/150/300ms) при write-conflict.

---

## 2) Graph Consistency: где возможны orphan’ы
### 2.1. Риск “shared atom” → массовое редактирование чужих документов
В Merge шаг 3:
```aql
FOR edge IN structure_links
  FILTER edge._to == CONCAT('atoms/', @current_active_id)
  UPDATE edge WITH { _to: CONCAT('atoms/', @winner_proposal_id) } IN structure_links
```
Если один и тот же atom (A) по ошибке/данным используется в нескольких местах (несколько входящих `structure_links`), этот update переключит **все места сразу**.

То же в Archive — удалит все `structure_links` на атом.

**Митигация:**
- либо enforce инвариант: **у атома максимум 1 входящий `structure_links` (contains)** (уникальный индекс/валидация),
- либо в API/транзакциях всегда передавать `parent_section_id`/`doc_id` и обновлять только соответствующее ребро.

### 2.2. Baseline snapshot может пропустить атомы
Create Baseline (3.3) делает обход `Doc -> Sections -> Atoms`, но сама модель `structure_links` допускает `docs/* -> atoms/*` напрямую.

Если это возможно в данных, baseline не зафиксирует такие атомы → «дырявый релиз».

**Митигация:**
- запретить `docs -> atoms` на уровне правил/валидации,
- или изменить baseline traversal на `FOR v,e,p IN 1..2 OUTBOUND @doc_id structure_links` и брать `v` где `IS_SAME_COLLECTION('atoms', v)`.

### 2.3. Orphan proposals
Сейчас proposals живут как `atoms(status=proposal)` + `proposal_links`.
- Если `proposal_links` удалится/не создастся (частичная запись вне транзакции или ручная ошибка) — получится **orphan proposal atom**, который UI не найдёт.

Спека предполагает транзакции — это хорошо, но стоит добавить явный **валидатор-скрипт** (интеграционный чек):
- `proposal` атом обязан иметь ровно 1 исходящий `proposal_links`.

### 2.4. Archive активного атома с существующими proposals
Archive удаляет `structure_links` и делает atom archived. Но proposals, которые ссылались на этот атом, остаются указывать на archived/не-в-структуре цель.

Это не смертельно, но UX/логика может стать странной: предложение «к тому, чего уже нет в документе».

**Митигация:** при archive:
- либо запрещать archive если есть inbound proposal_links,
- либо автоматически помечать такие proposals как `outdated`/`rejected`.

---

## 3) Логические gap’ы контрактов API
1) **Аутентификация/авторизация не определены**: раз API принимает `user_id` в body, любой клиент может подменить `user_id`.
   - Для блокировок и merge это фактически «security bypass», влияющий на целостность.
2) В ответах/запросах нет `_rev`/версии — поэтому сейчас нельзя реализовать устойчивый optimistic locking.
3) Не описаны коды/семантика ошибок для write-conflict/transaction conflict (например `409 CONFLICT`).

---

## 4) Вердикт
Спека v2.0 стала существенно более “production-minded” (immutability, baseline protection, auto-rebase, error artifacts), но **конкурентность пока не закрыта до конца**.

### Главный риск
**Merge + Lock без CAS** допускают состояние:
- два `active` атома на один логический слот,
- `active` атом вне `structure_links` (orphan active),
- “lock stealing”.

Пока эти пункты не исправлены, я **не могу выдать безоговорочный «Certificate of Architecture Quality»**.

### Условный сертификат (после правок)
Если вы добавите:
- CAS на `_rev` для lock/merge (или equivalent compare-and-swap на `structure_links`),
- unlock только владельцу,
- invariant/валидацию «atom имеет ≤1 входящий structure_link»,
- baseline traversal, покрывающий все допустимые пути,
- retry policy на write-conflict,

то архитектуру можно будет считать **устойчивой к гонкам и консистентной на уровне графа**.

Хочешь, я оформлю это как патч к спеки (короткие правки Section 3 + уточнения контрактов Section 2), чтобы PO мог утвердить финальную версию без двусмысленностей?