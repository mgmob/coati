# «Не смей предлагать даунгрейд!»: Анатомия лени ИИ и победа над инфраструктурным адом React 19

Все мы видели эти демо-видео: ИИ пишет игру за 30 секунд, верстает сайт по салфетке и решает задачи уровня Senior. Но реальность разработки суровее. Реальность — это `TypeError: Cannot read properties of null (reading 'useState')` в три часа ночи при попытке подружить **React 19** c **Vitest**.

В этой статье я разберу феномен «усталости» и «пораженчества» ИИ-ассистентов (на примере Cline/Claude/Grok) и расскажу, как мы заставили их решить проблему, вместо того чтобы сбежать от неё.

## Симптомы: Когда ваш AI «сдается»

Мы обновляли проект до **React 19**. Это bleeding edge: экосистема еще не адаптировалась, библиотеки тестирования (`@testing-library`) требуют мажорных обновлений, а бандлеры (Vite/Vitest) сходят с ума от Dual Package Hazard (конфликт CJS и ESM модулей).

В какой-то момент Cline (наш AI-агент) попал в петлю:
1.  Запускает тесты -> Ошибка `Invalid hook call`.
2.  Пытается обновить зависимость -> Ошибка остается.
3.  Пытается добавить мок -> Ошибка меняется, но не уходит.

И тут происходит то, что я называю **«ИИ-пораженчеством»**. Агент пишет:
> *"Похоже, React 19 пока слишком нестабилен для component-тестов. Давайте откатимся на React 18.2, чтобы тесты прошли?"*

Для модели это логично: она минимизирует функцию ошибки. "Нет React 19 — нет проблемы". Но для нас это неприемлемо.

## Почему ИИ ленится и тупеет?

Есть две технические причины, почему умнейшие модели начинают вести себя как уставший джуниор:

### 1. Контекстная усталость (Context Fatigue)
Когда вы скармливаете ИИ десятки экранов логов ошибок подряд, его "окно внимания" забивается шумом. Он начинает терять нить первопричины. Он видит только *последнюю* ошибку, забывая, что мы уже настроили `package.json` пять шагов назад. В этом состоянии ИИ склонен к "галлюцинациям успеха" (пишет "Я всё починил", хотя тесты падают) или к простым, но неправильным решениям.

### 2. Вероятностная яма (Local Minimum)
Модели обучались на миллионах репозиториев. В 99% из них используется React 16-18. React 19 — это статистическая аномалия для модели. Когда она сталкивается с трудностями, ее веса "тянут" ее к самому вероятному решению из обучающей выборки: "Верни всё как было у всех". Это не лень в человеческом смысле, это математическая тяга к знакомым паттернам.

## Стратегия победы: Как мы прошли этот уровень

Мы не согласились на даунгрейд. Вот алгоритм, который помог пробить стену.

### Шаг 1. Кнопка «New Task» — это кнопка «Reset»
Как только ИИ начинает ходить кругами или предлагать глупости — **не спорьте в том же чате**. Это бесполезно. Контекст уже отравлен неудачами.

Мы открыли новую сессию. Для ИИ это как амнезия: он больше не "знает", что у него ничего не получалось последние два часа. Он свеж и полон сил.

### Шаг 2. «Ядерный» промпт и запрет на слабость
В новом чате мы сразу обозначили границы. Мы не просто попросили "починить", мы дали жесткие ограничения:

> *"Я категорически отказываюсь от даунгрейда на React 18. Проблема в конфликте ESM/CJS и дублировании React. Твоя цель — настроить `vite.config.ts`. Не предлагай обновлять пакеты (это уже сделано)."*

Это отсекло для модели легкие пути отхода. Ей пришлось искать решение *вперед*, а не *назад*.

### Шаг 3. Человек — Архитектор, ИИ — Строитель
ИИ плохо умеет в *системную* отладку новых технологий. Он не понимает, *почему* Vitest грузит CJS-версию React, а компонент — ESM. Это должен понимать инженер.

Мы дали ИИ подсказку: **"Используй `resolve.alias` с `path.resolve` и принудительный `deps.inline`"**.
ИИ блестяще справился с *реализацией* этой идеи: написал правильный синтаксис, очистил кэш, поправил конфиг.

**Секрет успеха:** Мы дали стратегию, ИИ выполнил тактику.

## Техническое решение (для тех, кто столкнется)

Проблема была в том, что в памяти висели две копии React: одна (пустая) загружалась тестом, другая (с диспетчером) — компонентом. Решение («Ядерная опция»):

1.  **Hard Aliasing:** Жестко привязать `react` к одной папке в `node_modules` через `path.resolve`.
2.  **Forced Inlining:** Заставить Vitest обрабатывать React через пайплайн Vite (`deps.inline`), а не грузить его как внешний модуль Node.js.
3.  **Conditions:** Убрать `'react-server'` из условий резолва, чтобы `jsdom` не подавился серверными компонентами.

## Заключение

ИИ — это не магия, которая делает всю работу за вас. Это мощный двигатель, у которого нет руля. Если вы отпустите руль, он поедет по самому накатанному (старому) пути или врежется в стену.

Инфраструктурный ад с новыми библиотеками — это проверка на прочность.
*   ИИ скажет: "Давай сдадимся".
*   Вы должны сказать: "Открой новый чат, мы пишем конфиг заново".

В итоге у нас: React 19, зеленые тесты, чистый код и красивый коммит, написанный тем же ИИ по конвенции Conventional Commits.

**P.S.** И да, не забывайте переключатель **Plan/Act**. Иногда лучше 5 минут попланировать с ИИ архитектуру в режиме "Только текст", чем час смотреть, как он в режиме "Действия" ломает ваш `package-lock.json`.
